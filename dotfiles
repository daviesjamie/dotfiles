#!/usr/bin/env python

"""Dotfiles management system."""

import argparse
import glob
import os

# List of files inside the dotfiles repo to ignore (and not link), that
# aren't specified through .gitignore
IGNORED_FILES = [os.path.basename( __file__ ), '.git', 'README.md', 'osx.sh']

# Suffix to use when creating a backup of a file
BACKUP_SUFFIX = '~'

class SubcommandHelpFormatter( argparse.RawDescriptionHelpFormatter ):
    def _format_action( self, action ):
        parts = super( argparse.RawDescriptionHelpFormatter, self )._format_action( action )
        if action.nargs == argparse.PARSER:
            parts = "\n".join( parts.split( "\n" )[1:] )
        return parts

class GetFilePathAction( argparse.Action ):
    def __call__( self, parser, namespace, values, option_string=None ):
        setattr( namespace, self.dest, _dotfile_paths( values ) )

def _all_dotfiles():
    """Returns a list of the files in the dotfiles repository (assumed to be
    where this script is running from) that are actually valid dotfiles.

    A list of all the files in the dotfiles directory is narrowed down, with all
    files specified by the .gitignore file removed. All files that are
    arbitrarily specified in the IGNORED_FILES list are also removed. The
    resulting list is then returned.
    """

    # The dotfiles repo directory (assumed to be where this script is)
    dotfiles_repo = os.path.dirname( os.path.realpath( __file__ ) )

    # Get all files in the current directory
    dot_all = os.listdir( dotfiles_repo )

    # Ignore all files that match a .gitignore pattern
    gitignore = os.path.join( dotfiles_repo, '.gitignore' )
    dot_actual = dot_all[:]
    if os.path.exists( gitignore ):
        with open( gitignore ) as gi:
            for line in gi:
                if line != '\n' and not line.startswith( '#' ):
                    pattern = line.rstrip( '\n' )
                    patterns = [ pattern ]

                    # Use wildcards found in git
                    if pattern.startswith( '*' ):
                        patterns.append( '.' + pattern )    # *a == *a and .*a
                    if pattern.startswith( '*.' ):
                        patterns.append( pattern[1:] )      # *.b == *.b and .b

                    for pattern in patterns:
                        for path in glob.iglob( os.path.join( dotfiles_repo, pattern ) ):
                            name = os.path.basename( path )
                            if name in dot_actual:
                                dot_actual.remove( name )

    # Ignore any extra files that we have specified in the IGNORED_FILES list
    for igf in IGNORED_FILES:
        if igf in dot_actual:
            dot_actual.remove( igf )

    # Return a list of the actual dotfiles (with their paths)
    return dot_actual

def _dotfile_paths( files ):
    """ Returns a list containing the absolute paths to each of the files in the
    passed array.
    """
    return [_dotfile_path( file ) for file in files]

def _dotfile_path( filename ):
    """Returns the absolute path to a file in the dotfiles repo.
    Assumes that the dotfiles repo is the directory this script is in.
    """
    dotfiles_repo = os.path.dirname( os.path.realpath( __file__ ) )
    return os.path.join( dotfiles_repo, filename )

def _ask_yn( question ):
    """Presents the user with a question, and takes a yes (True) or no (False)
    answer in response.
    """
    
    question += ' (y/n):  '
    answer = None

    while answer not in ['yes', 'y', 'no', 'n']:
        answer = raw_input( question ).lower()

    return answer.startswith( 'y' )

def _pretty_basename( path ):
    """Returns the basename of the given path, with a trailing '/' if the
    basename of the path is a directory.
    """
    name = os.path.basename( path )
    if os.path.isdir( path ):
        name += '/'
    return name


def link( args ):
    """ Creates links to the specified dotfiles in the user's home directory."""
    
    home_dir = os.path.expanduser( '~' )
    all_dots = _all_dotfiles()

    for dotfile in sorted( args.files ):
        if dotfile not in all_dots:
            print dotfile + " is not in the repository!"
            print "Try using the add command to add the file to the repository first."
            return

        dest = os.path.join( home_dir, os.path.basename( dotfile ) )
        name = _pretty_basename( dotfile )
        installed = False

        while not installed:
            try:
                os.symlink( dotfile, dest )
            except OSError:
                # If the dest already exists, offer to back it up
                if not os.path.islink( dest ):
                    if not args.force:
                        backup = _ask_yn( name + ' already exists, back it up?' )
                    else:
                        backup = True
                    
                    if backup:
                        # Back up dest, using BACKUP_SUFFIX
                        backup_dest = dest + BACKUP_SUFFIX
                        while os.path.exists( backup_dest ):
                            backup_dest += BACKUP_SUFFIX

                        os.rename( dest, backup_dest )
                    else:
                        # Replace dest
                        os.remove( dest )
                else:
                    print name + ' is a link, deleting.'
                    os.remove( dest )
            else:
                # Successfully linked
                print name + ' linked.'
                installed = True

    print 'Done!'

def list( args ):
    """ Lists all the dotfiles in the repository that have been installed."""

    home_dir = os.path.expanduser( '~' )

    for dotfile in _all_dotfiles():
        # Get the path of the dotfile if it was in the home directory
        install_path = os.path.join( home_dir, os.path.basename( dotfile ) )

        # TODO: Check if link actually points to dotfile in this repo!
        if os.path.islink( install_path ):
            if not args.unlinked:
                print dotfile
        else:
            if args.unlinked:
                print dotfile

def add( args ):
    print args
    return

def edit( args ):
    print args
    return

def remove( args ):
    print args
    return


def _build_parser():
    """Constructs a parser for the command-line interface."""

    parser = argparse.ArgumentParser( formatter_class=SubcommandHelpFormatter )
    subparsers = parser.add_subparsers( title='commands' )

    # LINK
    parser_link = subparsers.add_parser( 'link' )
    parser_link.add_argument( 'files', nargs='*', default=_all_dotfiles(), action=GetFilePathAction )
    parser_link.add_argument( '-f', '--force', action='store_true' )
    parser_link.set_defaults( func=link )

    # LIST
    parser_list = subparsers.add_parser( 'list' )
    parser_list.add_argument( '-u', '--unlinked', action='store_true' )
    parser_list.set_defaults( func=list )

    # ADD
    parser_add = subparsers.add_parser( 'add' )
    parser_add.add_argument( 'files', nargs='+' )
    parser_add.set_defaults( func=add )
    
    # EDIT
    parser_edit = subparsers.add_parser( 'edit' )
    parser_edit.add_argument( 'file' )
    parser_edit.set_defaults( func=edit )

    # REMOVE
    parser_remove = subparsers.add_parser( 'remove' )
    parser_remove.set_defaults( func=remove )
    
    return parser

def _main():
    """Runs the command-line interface."""
    parser = _build_parser()
    args = parser.parse_args()
    args.func( args )


if __name__ == '__main__':
    _main()
